package iggy.gen.psi;

/* This file has been generated. */

import com.intellij.lang.ASTNode;
import com.intellij.psi.PsiElement;
import com.intellij.psi.tree.IElementType;
import iggy.gen.psi.IGGYElementType;
import iggy.gen.psi.impl.*;

public interface IGGYElementTypes {

    public IElementType LIST = new IGGYElementType("LIST");
    public IElementType OPT = new IGGYElementType("OPT");
    public IElementType ALT = new IGGYElementType("ALT");
    public IElementType SEQ = new IGGYElementType("SEQ");

    public IElementType KEYWORDS = new IGGYElementType("KEYWORDS");
    public IElementType REGEX_BRACKET = new IGGYElementType("REGEX_BRACKET");
    public IElementType REGEX_NONT = new IGGYElementType("REGEX_NONT");
    public IElementType REGEX_ALTERNATION = new IGGYElementType("REGEX_ALTERNATION");
    public IElementType REGEX_STAR = new IGGYElementType("REGEX_STAR");
    public IElementType REGEX_CHAR = new IGGYElementType("REGEX_CHAR");
    public IElementType REGEX_CHARCLASS = new IGGYElementType("REGEX_CHARCLASS");
    public IElementType REGEX_OPTION = new IGGYElementType("REGEX_OPTION");
    public IElementType REGEX_SEQUENCE = new IGGYElementType("REGEX_SEQUENCE");
    public IElementType REGEX_STRING = new IGGYElementType("REGEX_STRING");
    public IElementType REGEX_PLUS = new IGGYElementType("REGEX_PLUS");
    public IElementType NONTNAME$REFERENCE = new IGGYElementType("NONTNAME$REFERENCE");
    public IElementType ALTERNATES = new IGGYElementType("ALTERNATES");
    public IElementType VARNAME$REFERENCE = new IGGYElementType("VARNAME$REFERENCE");
    public IElementType EXPRESSION_BRACKET = new IGGYElementType("EXPRESSION_BRACKET");
    public IElementType EXPRESSION_CALL = new IGGYElementType("EXPRESSION_CALL");
    public IElementType EXPRESSION_MULTIPLICATION = new IGGYElementType("EXPRESSION_MULTIPLICATION");
    public IElementType EXPRESSION_OR = new IGGYElementType("EXPRESSION_OR");
    public IElementType EXPRESSION_NOTEQUAL = new IGGYElementType("EXPRESSION_NOTEQUAL");
    public IElementType EXPRESSION_GREATEREQ = new IGGYElementType("EXPRESSION_GREATEREQ");
    public IElementType EXPRESSION_NAME = new IGGYElementType("EXPRESSION_NAME");
    public IElementType EXPRESSION_LESSEQ = new IGGYElementType("EXPRESSION_LESSEQ");
    public IElementType EXPRESSION_REXTENT = new IGGYElementType("EXPRESSION_REXTENT");
    public IElementType EXPRESSION_NUMBER = new IGGYElementType("EXPRESSION_NUMBER");
    public IElementType EXPRESSION_EQUAL = new IGGYElementType("EXPRESSION_EQUAL");
    public IElementType EXPRESSION_AND = new IGGYElementType("EXPRESSION_AND");
    public IElementType EXPRESSION_YIELD = new IGGYElementType("EXPRESSION_YIELD");
    public IElementType EXPRESSION_GREATER = new IGGYElementType("EXPRESSION_GREATER");
    public IElementType EXPRESSION_DIVISION = new IGGYElementType("EXPRESSION_DIVISION");
    public IElementType EXPRESSION_PLUS = new IGGYElementType("EXPRESSION_PLUS");
    public IElementType EXPRESSION_LESS = new IGGYElementType("EXPRESSION_LESS");
    public IElementType EXPRESSION_MINUS = new IGGYElementType("EXPRESSION_MINUS");
    public IElementType EXPRESSION_LEXTENT = new IGGYElementType("EXPRESSION_LEXTENT");
    public IElementType SYMBOL_CALL = new IGGYElementType("SYMBOL_CALL");
    public IElementType SYMBOL_NONT = new IGGYElementType("SYMBOL_NONT");
    public IElementType SYMBOL_IGNORE = new IGGYElementType("SYMBOL_IGNORE");
    public IElementType SYMBOL_EXCLUDE = new IGGYElementType("SYMBOL_EXCLUDE");
    public IElementType SYMBOL_VARIABLE = new IGGYElementType("SYMBOL_VARIABLE");
    public IElementType SYMBOL_ALIGN = new IGGYElementType("SYMBOL_ALIGN");
    public IElementType SYMBOL_LABELED = new IGGYElementType("SYMBOL_LABELED");
    public IElementType SYMBOL_CONDITIONAL = new IGGYElementType("SYMBOL_CONDITIONAL");
    public IElementType SYMBOL_STRING = new IGGYElementType("SYMBOL_STRING");
    public IElementType SYMBOL_OFFSIDE = new IGGYElementType("SYMBOL_OFFSIDE");
    public IElementType SYMBOL_SEQUENCE = new IGGYElementType("SYMBOL_SEQUENCE");
    public IElementType SYMBOL_BINDINGS = new IGGYElementType("SYMBOL_BINDINGS");
    public IElementType SYMBOL_FOLLOW = new IGGYElementType("SYMBOL_FOLLOW");
    public IElementType SYMBOL_CONSTRAINTS = new IGGYElementType("SYMBOL_CONSTRAINTS");
    public IElementType SYMBOL_ALTERNATION = new IGGYElementType("SYMBOL_ALTERNATION");
    public IElementType SYMBOL_REGEX = new IGGYElementType("SYMBOL_REGEX");
    public IElementType SYMBOL_NOTFOLLOW = new IGGYElementType("SYMBOL_NOTFOLLOW");
    public IElementType SYMBOL_STAR = new IGGYElementType("SYMBOL_STAR");
    public IElementType SYMBOL_CHAR = new IGGYElementType("SYMBOL_CHAR");
    public IElementType SYMBOL_OPTION = new IGGYElementType("SYMBOL_OPTION");
    public IElementType SYMBOL_PLUS = new IGGYElementType("SYMBOL_PLUS");
    public IElementType SYMBOL_EXCEPT = new IGGYElementType("SYMBOL_EXCEPT");
    public IElementType SYMBOL_PRECEDE = new IGGYElementType("SYMBOL_PRECEDE");
    public IElementType SYMBOL_NOTPRECEDE = new IGGYElementType("SYMBOL_NOTPRECEDE");
    public IElementType VARNAME$DECLARATION = new IGGYElementType("VARNAME$DECLARATION");
    public IElementType SYMBOLS = new IGGYElementType("SYMBOLS");
    public IElementType ALTERNATE_SEQUENCE = new IGGYElementType("ALTERNATE_SEQUENCE");
    public IElementType ALTERNATE_ASSOC = new IGGYElementType("ALTERNATE_ASSOC");
    public IElementType VARNAME = new IGGYElementType("VARNAME");
    public IElementType NONTNAME = new IGGYElementType("NONTNAME");
    public IElementType RANGE = new IGGYElementType("RANGE");
    public IElementType NONTNAME$DECLARATION = new IGGYElementType("NONTNAME$DECLARATION");
    public IElementType RULE_REGEX = new IGGYElementType("RULE_REGEX");
    public IElementType RULE_SYNTAX = new IGGYElementType("RULE_SYNTAX");
    public IElementType ATTRIBUTE_LABEL = new IGGYElementType("ATTRIBUTE_LABEL");
    public IElementType ATTRIBUTE_ASSOC = new IGGYElementType("ATTRIBUTE_ASSOC");
    public IElementType LABEL = new IGGYElementType("LABEL");
    public IElementType RETURN = new IGGYElementType("RETURN");
    public IElementType DEFINITION = new IGGYElementType("DEFINITION");
    public IElementType TAG = new IGGYElementType("TAG");
    public IElementType ASSOCIATIVITY = new IGGYElementType("ASSOCIATIVITY");
    public IElementType WHITESPACEORCOMMENT = new IGGYElementType("WHITESPACEORCOMMENT");
    public IElementType ARGUMENTS = new IGGYElementType("ARGUMENTS");
    public IElementType REGEXBODY = new IGGYElementType("REGEXBODY");
    public IElementType REGEXSEQUENCE = new IGGYElementType("REGEXSEQUENCE");
    public IElementType ALTLABEL = new IGGYElementType("ALTLABEL");
    public IElementType PARAMETERS = new IGGYElementType("PARAMETERS");
    public IElementType REGEXS = new IGGYElementType("REGEXS");
    public IElementType SEQUENCE = new IGGYElementType("SEQUENCE");
    public IElementType IDENTIFIER = new IGGYElementType("IDENTIFIER");
    public IElementType CHARCLASS_NOTCHARS = new IGGYElementType("CHARCLASS_NOTCHARS");
    public IElementType CHARCLASS_CHARS = new IGGYElementType("CHARCLASS_CHARS");
    public IElementType BODY = new IGGYElementType("BODY");
    public IElementType LAYOUT = new IGGYElementType("LAYOUT");
    public IElementType BINDING_ASSIGNMENT = new IGGYElementType("BINDING_ASSIGNMENT");
    public IElementType BINDING_DECLARATION = new IGGYElementType("BINDING_DECLARATION");

    public static IElementType get(String name) {
        switch (name) {
            case "LIST": return LIST;
            case "OPT": return OPT;
            case "ALT": return ALT;
            case "SEQ": return SEQ;
            case "KEYWORDS": return KEYWORDS;
            case "REGEX_BRACKET": return REGEX_BRACKET;
            case "REGEX_NONT": return REGEX_NONT;
            case "REGEX_ALTERNATION": return REGEX_ALTERNATION;
            case "REGEX_STAR": return REGEX_STAR;
            case "REGEX_CHAR": return REGEX_CHAR;
            case "REGEX_CHARCLASS": return REGEX_CHARCLASS;
            case "REGEX_OPTION": return REGEX_OPTION;
            case "REGEX_SEQUENCE": return REGEX_SEQUENCE;
            case "REGEX_STRING": return REGEX_STRING;
            case "REGEX_PLUS": return REGEX_PLUS;
            case "NONTNAME$REFERENCE": return NONTNAME$REFERENCE;
            case "ALTERNATES": return ALTERNATES;
            case "VARNAME$REFERENCE": return VARNAME$REFERENCE;
            case "EXPRESSION_BRACKET": return EXPRESSION_BRACKET;
            case "EXPRESSION_CALL": return EXPRESSION_CALL;
            case "EXPRESSION_MULTIPLICATION": return EXPRESSION_MULTIPLICATION;
            case "EXPRESSION_OR": return EXPRESSION_OR;
            case "EXPRESSION_NOTEQUAL": return EXPRESSION_NOTEQUAL;
            case "EXPRESSION_GREATEREQ": return EXPRESSION_GREATEREQ;
            case "EXPRESSION_NAME": return EXPRESSION_NAME;
            case "EXPRESSION_LESSEQ": return EXPRESSION_LESSEQ;
            case "EXPRESSION_REXTENT": return EXPRESSION_REXTENT;
            case "EXPRESSION_NUMBER": return EXPRESSION_NUMBER;
            case "EXPRESSION_EQUAL": return EXPRESSION_EQUAL;
            case "EXPRESSION_AND": return EXPRESSION_AND;
            case "EXPRESSION_YIELD": return EXPRESSION_YIELD;
            case "EXPRESSION_GREATER": return EXPRESSION_GREATER;
            case "EXPRESSION_DIVISION": return EXPRESSION_DIVISION;
            case "EXPRESSION_PLUS": return EXPRESSION_PLUS;
            case "EXPRESSION_LESS": return EXPRESSION_LESS;
            case "EXPRESSION_MINUS": return EXPRESSION_MINUS;
            case "EXPRESSION_LEXTENT": return EXPRESSION_LEXTENT;
            case "SYMBOL_CALL": return SYMBOL_CALL;
            case "SYMBOL_NONT": return SYMBOL_NONT;
            case "SYMBOL_IGNORE": return SYMBOL_IGNORE;
            case "SYMBOL_EXCLUDE": return SYMBOL_EXCLUDE;
            case "SYMBOL_VARIABLE": return SYMBOL_VARIABLE;
            case "SYMBOL_ALIGN": return SYMBOL_ALIGN;
            case "SYMBOL_LABELED": return SYMBOL_LABELED;
            case "SYMBOL_CONDITIONAL": return SYMBOL_CONDITIONAL;
            case "SYMBOL_STRING": return SYMBOL_STRING;
            case "SYMBOL_OFFSIDE": return SYMBOL_OFFSIDE;
            case "SYMBOL_SEQUENCE": return SYMBOL_SEQUENCE;
            case "SYMBOL_BINDINGS": return SYMBOL_BINDINGS;
            case "SYMBOL_FOLLOW": return SYMBOL_FOLLOW;
            case "SYMBOL_CONSTRAINTS": return SYMBOL_CONSTRAINTS;
            case "SYMBOL_ALTERNATION": return SYMBOL_ALTERNATION;
            case "SYMBOL_REGEX": return SYMBOL_REGEX;
            case "SYMBOL_NOTFOLLOW": return SYMBOL_NOTFOLLOW;
            case "SYMBOL_STAR": return SYMBOL_STAR;
            case "SYMBOL_CHAR": return SYMBOL_CHAR;
            case "SYMBOL_OPTION": return SYMBOL_OPTION;
            case "SYMBOL_PLUS": return SYMBOL_PLUS;
            case "SYMBOL_EXCEPT": return SYMBOL_EXCEPT;
            case "SYMBOL_PRECEDE": return SYMBOL_PRECEDE;
            case "SYMBOL_NOTPRECEDE": return SYMBOL_NOTPRECEDE;
            case "VARNAME$DECLARATION": return VARNAME$DECLARATION;
            case "SYMBOLS": return SYMBOLS;
            case "ALTERNATE_SEQUENCE": return ALTERNATE_SEQUENCE;
            case "ALTERNATE_ASSOC": return ALTERNATE_ASSOC;
            case "VARNAME": return VARNAME;
            case "NONTNAME": return NONTNAME;
            case "RANGE": return RANGE;
            case "NONTNAME$DECLARATION": return NONTNAME$DECLARATION;
            case "RULE_REGEX": return RULE_REGEX;
            case "RULE_SYNTAX": return RULE_SYNTAX;
            case "ATTRIBUTE_LABEL": return ATTRIBUTE_LABEL;
            case "ATTRIBUTE_ASSOC": return ATTRIBUTE_ASSOC;
            case "LABEL": return LABEL;
            case "RETURN": return RETURN;
            case "DEFINITION": return DEFINITION;
            case "TAG": return TAG;
            case "ASSOCIATIVITY": return ASSOCIATIVITY;
            case "WHITESPACEORCOMMENT": return WHITESPACEORCOMMENT;
            case "ARGUMENTS": return ARGUMENTS;
            case "REGEXBODY": return REGEXBODY;
            case "REGEXSEQUENCE": return REGEXSEQUENCE;
            case "ALTLABEL": return ALTLABEL;
            case "PARAMETERS": return PARAMETERS;
            case "REGEXS": return REGEXS;
            case "SEQUENCE": return SEQUENCE;
            case "IDENTIFIER": return IDENTIFIER;
            case "CHARCLASS_NOTCHARS": return CHARCLASS_NOTCHARS;
            case "CHARCLASS_CHARS": return CHARCLASS_CHARS;
            case "BODY": return BODY;
            case "LAYOUT": return LAYOUT;
            case "BINDING_ASSIGNMENT": return BINDING_ASSIGNMENT;
            case "BINDING_DECLARATION": return BINDING_DECLARATION;
        }
        throw new RuntimeException("Should not have happened!");
    }

    class Factory {
        public static PsiElement createElement(ASTNode node) {
            IElementType type = node.getElementType();
            if (type == LIST || type == OPT || type == ALT || type == SEQ) return new EbnfElementImpl(node);
            if (type == KEYWORDS) return new KeywordsImpl(node);
            if (type == REGEX_BRACKET) return new RegexBracketImpl(node);
            if (type == REGEX_NONT) return new RegexNontImpl(node);
            if (type == REGEX_ALTERNATION) return new RegexAlternationImpl(node);
            if (type == REGEX_STAR) return new RegexStarImpl(node);
            if (type == REGEX_CHAR) return new RegexCharImpl(node);
            if (type == REGEX_CHARCLASS) return new RegexCharClassImpl(node);
            if (type == REGEX_OPTION) return new RegexOptionImpl(node);
            if (type == REGEX_SEQUENCE) return new RegexSequenceImpl(node);
            if (type == REGEX_STRING) return new RegexStringImpl(node);
            if (type == REGEX_PLUS) return new RegexPlusImpl(node);
            if (type == NONTNAME$REFERENCE) return new NontName$ReferenceImpl(node);
            if (type == ALTERNATES) return new AlternatesImpl(node);
            if (type == VARNAME$REFERENCE) return new VarName$ReferenceImpl(node);
            if (type == EXPRESSION_BRACKET) return new ExpressionBracketImpl(node);
            if (type == EXPRESSION_CALL) return new ExpressionCallImpl(node);
            if (type == EXPRESSION_MULTIPLICATION) return new ExpressionMultiplicationImpl(node);
            if (type == EXPRESSION_OR) return new ExpressionOrImpl(node);
            if (type == EXPRESSION_NOTEQUAL) return new ExpressionNotEqualImpl(node);
            if (type == EXPRESSION_GREATEREQ) return new ExpressionGreaterEqImpl(node);
            if (type == EXPRESSION_NAME) return new ExpressionNameImpl(node);
            if (type == EXPRESSION_LESSEQ) return new ExpressionLessEqImpl(node);
            if (type == EXPRESSION_REXTENT) return new ExpressionRExtentImpl(node);
            if (type == EXPRESSION_NUMBER) return new ExpressionNumberImpl(node);
            if (type == EXPRESSION_EQUAL) return new ExpressionEqualImpl(node);
            if (type == EXPRESSION_AND) return new ExpressionAndImpl(node);
            if (type == EXPRESSION_YIELD) return new ExpressionYieldImpl(node);
            if (type == EXPRESSION_GREATER) return new ExpressionGreaterImpl(node);
            if (type == EXPRESSION_DIVISION) return new ExpressionDivisionImpl(node);
            if (type == EXPRESSION_PLUS) return new ExpressionPlusImpl(node);
            if (type == EXPRESSION_LESS) return new ExpressionLessImpl(node);
            if (type == EXPRESSION_MINUS) return new ExpressionMinusImpl(node);
            if (type == EXPRESSION_LEXTENT) return new ExpressionLExtentImpl(node);
            if (type == SYMBOL_CALL) return new SymbolCallImpl(node);
            if (type == SYMBOL_NONT) return new SymbolNontImpl(node);
            if (type == SYMBOL_IGNORE) return new SymbolIgnoreImpl(node);
            if (type == SYMBOL_EXCLUDE) return new SymbolExcludeImpl(node);
            if (type == SYMBOL_VARIABLE) return new SymbolVariableImpl(node);
            if (type == SYMBOL_ALIGN) return new SymbolAlignImpl(node);
            if (type == SYMBOL_LABELED) return new SymbolLabeledImpl(node);
            if (type == SYMBOL_CONDITIONAL) return new SymbolConditionalImpl(node);
            if (type == SYMBOL_STRING) return new SymbolStringImpl(node);
            if (type == SYMBOL_OFFSIDE) return new SymbolOffsideImpl(node);
            if (type == SYMBOL_SEQUENCE) return new SymbolSequenceImpl(node);
            if (type == SYMBOL_BINDINGS) return new SymbolBindingsImpl(node);
            if (type == SYMBOL_FOLLOW) return new SymbolFollowImpl(node);
            if (type == SYMBOL_CONSTRAINTS) return new SymbolConstraintsImpl(node);
            if (type == SYMBOL_ALTERNATION) return new SymbolAlternationImpl(node);
            if (type == SYMBOL_REGEX) return new SymbolRegexImpl(node);
            if (type == SYMBOL_NOTFOLLOW) return new SymbolNotFollowImpl(node);
            if (type == SYMBOL_STAR) return new SymbolStarImpl(node);
            if (type == SYMBOL_CHAR) return new SymbolCharImpl(node);
            if (type == SYMBOL_OPTION) return new SymbolOptionImpl(node);
            if (type == SYMBOL_PLUS) return new SymbolPlusImpl(node);
            if (type == SYMBOL_EXCEPT) return new SymbolExceptImpl(node);
            if (type == SYMBOL_PRECEDE) return new SymbolPrecedeImpl(node);
            if (type == SYMBOL_NOTPRECEDE) return new SymbolNotPrecedeImpl(node);
            if (type == VARNAME$DECLARATION) return new VarName$DeclarationImpl(node);
            if (type == SYMBOLS) return new SymbolsImpl(node);
            if (type == ALTERNATE_SEQUENCE) return new AlternateSequenceImpl(node);
            if (type == ALTERNATE_ASSOC) return new AlternateAssocImpl(node);
            if (type == VARNAME) return new VarNameImpl(node);
            if (type == NONTNAME) return new NontNameImpl(node);
            if (type == RANGE) return new RangeImpl(node);
            if (type == NONTNAME$DECLARATION) return new NontName$DeclarationImpl(node);
            if (type == RULE_REGEX) return new RuleRegexImpl(node);
            if (type == RULE_SYNTAX) return new RuleSyntaxImpl(node);
            if (type == ATTRIBUTE_LABEL) return new AttributeLabelImpl(node);
            if (type == ATTRIBUTE_ASSOC) return new AttributeAssocImpl(node);
            if (type == LABEL) return new LabelImpl(node);
            if (type == RETURN) return new ReturnImpl(node);
            if (type == DEFINITION) return new DefinitionImpl(node);
            if (type == TAG) return new TagImpl(node);
            if (type == ASSOCIATIVITY) return new AssociativityImpl(node);
            if (type == WHITESPACEORCOMMENT) return new WhiteSpaceOrCommentImpl(node);
            if (type == ARGUMENTS) return new ArgumentsImpl(node);
            if (type == REGEXBODY) return new RegexBodyImpl(node);
            if (type == REGEXSEQUENCE) return new RegexSequenceImpl(node);
            if (type == ALTLABEL) return new AltLabelImpl(node);
            if (type == PARAMETERS) return new ParametersImpl(node);
            if (type == REGEXS) return new RegexsImpl(node);
            if (type == SEQUENCE) return new SequenceImpl(node);
            if (type == IDENTIFIER) return new IdentifierImpl(node);
            if (type == CHARCLASS_NOTCHARS) return new CharClassNotCharsImpl(node);
            if (type == CHARCLASS_CHARS) return new CharClassCharsImpl(node);
            if (type == BODY) return new BodyImpl(node);
            if (type == LAYOUT) return new LayoutImpl(node);
            if (type == BINDING_ASSIGNMENT) return new BindingAssignmentImpl(node);
            if (type == BINDING_DECLARATION) return new BindingDeclarationImpl(node);
            throw new RuntimeException("Should not have happened!");
        }
    }
}
